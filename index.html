<!DOCTYPE html>
<html>
    <head>
        <title>Computer Syllabus</title>
        <style>
            
            .navigation {
                background-color: rgb(199, 230, 230);
                text-align: justify;
            }
            .left {
                float: left;
                color: rgb(255, 255, 255);
                text-align: center;
                padding: 14px 16px;
                text-decoration: none;
                font-size: 17px;
                cursor: pointer;
            }
            .heads{
                color: rgb(0, 0, 0);
                text-align: center;
                padding: 25px;
            }
            .topnav{
                overflow: hidden;
                background-color: rgba(0, 0, 0, 0.729);
                position: sticky;
                color: aliceblue;
                top: 0;
               
            }
            .text{
                color: rgb(0, 0, 0);
                font-family: 'Times New Roman', Times, serif;
                font-size: 20px;
               
                text-align: justify;
            }
            body {
                background-color: #59999d81;
                font-family: 'Times New Roman', Times, serif;
                font-size: 12px;
                margin: 0;
            }
            h1{font-size: 30px;}
            .subhead {
                color: #0e5358ab;
                text-align: justify;
                font-size: larger;
            }
            h3{font-size: 25px;}
            .border {
                border: 12px solid black; 
                border-radius: 2%;
                padding: 20px;
                margin: 40px;
                background-color: white;
                box-shadow: 0px 4px 10px rgb(0, 0, 0);
            }
        </style>
    </head>
    <body class="navigation">
        <div class="heads">
            <h1>Grade 12</h1>
        </div>
        <div class="topnav"> 
            <a href="#syllabus" class="left"> Syllabus</a>
            <a href="#chapter1" class="left">Chapter 1</a>
            <a href="#chapter2" class="left">Chapter 2</a>
            <a href="#chapter3" class="left">Chapter 3</a>
            <a href="#chapter4" class="left">Chapter 4</a>
            <a href="#chapter5" class="left">Chapter 5</a>
            <a href="#chapter6" class="left">Chapter 6</a>
            <a href="#chapter7" class="left">Chapter 7</a>
            <a href="#chapter8" class="left">Chapter 8</a>
          
           
        </div>
        <div id="syllabus" class="border">
    <h1> Syllabus</h1>
    <div class="text">
    <table border="1" cellpadding="5" cellspacing="0" width="50%" height="250px">
        <thead>
        <tr>
            <th>S.N.</th>
            <th> Topic</th>
            <th>Content wise marks</th>
            <th> Working Hours</th>
        </tr>
        <tr>
            <td>1</td>
            <td>Database management system</td>
            <td>8</td>
            <td>12</td>
        </tr>   
        <tr>
            <td>2</td>
            <td>Data communication and networking</td>
            <td>9</td>
            <td>15</td>
         </tr>
         <tr>
            <Td>3</Td>
            <td>Web Tech- II</td>
            <td>8</td>
            <td>12</td>

         </tr>
         <tr>
            <td>4</td>
            <td>C programming -II </td>
            <td>8</td>
            <td>12</td>
         </tr>   
         <tr>
            <td>5</td>
            <td>Object Oriented Programming</td>
            <td>6</td>
            <td>10</td>

         </tr>
         <tr>
         <td>6</td>
         <td>Software devolopment life cycle</td>
         <td>6</td>
         <td>10</td>
         </tr>
         <tr>
            <td>7</td>
            <td>
                Recent Trends in Technology
            </td>
            <td>5</td>
            <td>9</td>
         </tr>
         <tr>
            <td colspan="2" align="center"><strong>Total</strong></td>
            <td><b>50</b></td>
            <td><b>80</b></td>
         </tr>
        </thead>
    </table> 

</div>
</div>
        <div id="chapter1" class="border">
<div class="text">        
<div>
  <div class="subhead"> <h2> Data vs Information</h2></div>
  <div class="text"><strong>Data</strong> consists of raw facts and figures that by themselves do not carry meaning. These can be numbers, text, images, or sounds collected from various sources. Data alone cannot help in decision-making without interpretation. For example, a temperature reading of "30" is data until you know whether it's in Celsius or Fahrenheit, the location, or time.</p>
  <p><strong>Information</strong> is the processed form of data that is meaningful and useful. It results from organizing, structuring, or presenting data in context. For example, "The temperature in New York on June 15th was 30°C, which is higher than the average" is information because it adds context, making the data valuable for analysis or decisions.</p>
  <p>Understanding the distinction is crucial for fields like data science, business intelligence, and database management where the goal is to convert raw data into actionable information.</p>
</div>
  <div class="subhead"><h2>Features of Information</h2></div>
  <ul>
    <li><strong>Accuracy:</strong> Information must be precise and error-free. Inaccurate information can lead to poor decisions or business losses.</li>
    <li><strong>Timeliness:</strong> Information must be available when needed. Outdated information might be irrelevant or misleading.</li>
    <li><strong>Relevance:</strong> The information should be applicable to the purpose it serves, ensuring it meets the needs of users or processes.</li>
    <li><strong>Completeness:</strong> All necessary details should be present for the information to be fully understood and actionable.</li>
    <li><strong>Consistency:</strong> Information should be consistent across different sources and over time to build trust and reliability.</li>
    <li><strong>Understandability:</strong> Information should be presented clearly and understandably so that users can interpret it correctly.</li>
    <li><strong>Accessibility:</strong> Authorized users should be able to easily access the information when needed without unnecessary hurdles.</li>
  </ul>

  <div class="subhead"><h2>Database and Its Purpose</h2></div>
  <p>A <strong>database</strong> is a collection of related data organized systematically to facilitate easy access, management, and updating. Databases enable users to store vast amounts of information securely and retrieve it quickly using query languages like SQL.</p>
  <p>The primary purpose of a database is to support efficient data storage, retrieval, and manipulation, enabling applications to serve user needs effectively. Databases eliminate redundant data storage, provide data integrity, and support concurrent access by multiple users, which is essential in modern multi-user environments such as banking, e-commerce, and social networking.</p>
  <p>For example, in an online store, a database maintains records of products, customers, orders, and payments, allowing seamless operations like searching products, placing orders, and tracking shipments.</p>

 <div class="subhead"> <h2>Terminologies in Database</h2></div>
  <ul>
    <li><strong>Table:</strong> The basic unit of data storage in relational databases. Each table contains rows (records) and columns (fields), representing entities such as employees or products.</li>
    <li><strong>Field:</strong> A column in a table, defining the data type and meaning of the data stored. For example, "Name," "Date of Birth," or "Price."</li>
    <li><strong>Record:</strong> A row in a table representing a single entity instance, such as a specific employee or product entry.</li>
    <li><strong>Tuple:</strong> Synonymous with a record, emphasizing its ordered structure in a table.</li>
    <li><strong>Object:</strong> In object-oriented or object-relational databases, an object is a data entity encapsulating attributes and behaviors, representing real-world entities more naturally.</li>
    <li><strong>Keys:</strong> Fields that uniquely identify records or establish relationships:
      <ul>
        <li><em>Primary Key:</em> A unique identifier for each record in a table (e.g., employee ID).</li>
        <li><em>Foreign Key:</em> A field in one table that links to the primary key in another, establishing relational connections.</li>
      </ul>
    </li>
  </ul>

  <div class="subhead"><h2>Data Dictionary</h2></div>
  <p>The <strong>data dictionary</strong> is an essential metadata repository in a database system that stores definitions, constraints, and structural information about data elements and their relationships. It acts as a blueprint, documenting the design and structure of the database to aid developers, DBAs, and users in understanding and managing the data.</p>
  <p>It typically includes:</p>
  <ul>
    <li>Table names and descriptions</li>
    <li>Field names, data types, and allowed values</li>
    <li>Relationships and constraints between tables</li>
    <li>Access permissions and user roles</li>
  </ul>
  <p>An accurate data dictionary is crucial for maintaining data integrity, consistency, and facilitating changes or upgrades in the database structure over time.</p>

  <div class="subhead"><h2>Database Management System (DBMS)</h2></div>
  <h3>Introduction</h3>
  <p>A <strong>DBMS</strong> is a sophisticated software system that provides an interface to define, create, query, update, and administer databases. It abstracts the complexity of data storage and management from users, enabling efficient handling of large data volumes and concurrent multi-user access.</p>
  <p>Popular DBMS examples include MySQL, Oracle, Microsoft SQL Server, and PostgreSQL, widely used in enterprise and web applications.</p>

  <h3>Objectives</h3>
  <ul>
    <li>Provide a convenient and efficient environment for users to store and retrieve data.</li>
    <li>Ensure data integrity, security, and privacy.</li>
    <li>Enable concurrent multi-user access with transaction management.</li>
    <li>Provide backup, recovery, and fault tolerance mechanisms.</li>
    <li>Maintain data independence by separating physical and logical data structures.</li>
  </ul>

  <h3>Advantages</h3>
  <ul>
    <li><strong>Data Integrity:</strong> DBMS enforces rules to maintain accuracy and consistency of data.</li>
    <li><strong>Security:</strong> Access controls restrict unauthorized data access and manipulation.</li>
    <li><strong>Reduced Redundancy:</strong> Data normalization eliminates duplication, saving storage and improving consistency.</li>
    <li><strong>Backup and Recovery:</strong> DBMS automates data backup and recovery, minimizing data loss risks.</li>
    <li><strong>Multi-User Access:</strong> Supports concurrent access while preventing conflicts through locking and transactions.</li>
  </ul>

  <h3>Disadvantages</h3>
  <ul>
    <li><strong>Complexity:</strong> Setting up and managing a DBMS requires skilled personnel and planning.</li>
    <li><strong>Cost:</strong> Licensing, hardware, and maintenance can be expensive.</li>
    <li><strong>Performance Overhead:</strong> Additional layers of abstraction may impact speed compared to file-based systems.</li>
    <li><strong>Single Point of Failure:</strong> Centralized DBMS can cause system-wide downtime if not designed with fault tolerance.</li>
  </ul>

  <div class="subhead"><h2>Types of Database Models</h2></div>
  <ul>
    <li><strong>Hierarchical Model:</strong>
      <p>Organizes data in a tree-like structure with parent-child relationships, where each child record has only one parent. This model is efficient for representing structured data like organizational charts, XML data, or file systems. However, its rigid hierarchy limits flexibility in representing complex relationships.</p>
    </li>
    <li><strong>Network Model:</strong>
      <p>Extends the hierarchical model by allowing multiple parent records, forming a graph structure. This many-to-many relationship model supports more complex real-world scenarios such as supply chains or telecommunications. Though flexible, network models are complex to design and manage.</p>
    </li>
    <li><strong>Relational Model:</strong>
      <p>The most widely used model today, it stores data in tables (relations) with rows and columns. Data relationships are established using keys, and operations are performed using relational algebra and SQL. This model offers simplicity, data independence, and flexibility, making it suitable for most business applications.</p>
    </li>
    <li><strong>Entity-Relationship Model:</strong>
      <p>Primarily used for database design, this conceptual model uses diagrams (ER diagrams) to illustrate entities, attributes, and relationships. It helps in visualizing and planning the database structure before implementation.</p>
    </li>
  </ul>

  <div class="subhead"><h2>Integrity Constraints and Types</h2></div>
  <p>Integrity constraints enforce rules on data to ensure accuracy, consistency, and reliability in a database.</p>
  <ul>
    <li><strong>Domain Constraint:</strong> Defines the permissible set of values for a column, such as data type restrictions, value ranges, or formats (e.g., a date field must be a valid date).</li>
    <li><strong>Entity Integrity:</strong> Ensures that each table’s primary key is unique and not null, so every record is uniquely identifiable.</li>
    <li><strong>Referential Integrity:</strong> Maintains valid relationships between tables by ensuring foreign keys correspond to existing primary keys. It prevents orphan records and maintains relational consistency.</li>
    <li><strong>Key Constraints:</strong> Enforce uniqueness and correct usage of primary and foreign keys to maintain data consistency.</li>
  </ul>

  <div class="subhead"><h2>Normalization</h2></div>
  <h3>Introduction</h3>
  <p>Normalization is a systematic approach of decomposing tables to minimize data redundancy and eliminate undesirable characteristics like update, insert, and delete anomalies. It improves data integrity and efficiency in relational databases by organizing data into multiple related tables.</p>
  <p>Normalization follows several stages called normal forms, each with specific rules:</p>

  <h3>Normal Forms</h3>
  <ul>
    <li><strong>First Normal Form (1NF):</strong> Ensures that all table columns contain atomic, indivisible values, and there are no repeating groups or arrays within rows.</li>
    <li><strong>Second Normal Form (2NF):</strong> Achieved when the table is in 1NF and all non-key attributes are fully functionally dependent on the entire primary key, removing partial dependencies.</li>
    <li><strong>Third Normal Form (3NF):</strong> Reached when the table is in 2NF and all attributes are only dependent on the primary key, eliminating transitive dependencies.</li>
  </ul>

  <h3>Advantages of Normalization</h3>
  <ul>
    <li>Eliminates redundant data, reducing storage needs.</li>
    <li>Ensures data consistency and accuracy.</li>
    <li>Makes the database easier to maintain and update.</li>
    <li>Improves query performance by structuring data efficiently.</li>
  </ul>

  <h3>Disadvantages of Normalization</h3>
  <ul>
    <li>Increased number of tables can make queries more complex and slower due to joins.</li>
    <li>Over-normalization may result in performance bottlenecks.</li>
    <li>Sometimes denormalization is preferred for read-heavy applications to improve speed.</li>
  </ul>

  <div class="subhead"><h2>Centralized and Distributed Database</h2></div></div>
  <h3>Introduction</h3>
  <p><strong>Centralized Database</strong> systems store data in a single central location managed by one DBMS instance. All data access, processing, and administration occur on this central server.</p>
  <p><strong>Distributed Database</strong> systems distribute data across multiple physical locations, connected through a network but appear as a single database to users. This approach can enhance performance, fault tolerance, and scalability.</p>

  <h3>Advantages</h3>
  <ul>
    <li><strong>Centralized:</strong> Easier management, simplified backup, and strong data integrity due to centralized control.</li>
    <li><strong>Distributed:</strong> Improved reliability (no single point of failure), better performance by localizing data access, and scalability by adding nodes.</li>
  </ul>

  <h3>Disadvantages</h3>
  <ul>
    <li><strong>Centralized:</strong> Potential bottlenecks and vulnerability to single points of failure.</li>
    <li><strong>Distributed:</strong> Complex data synchronization, possible consistency issues, and higher maintenance costs.</li>
  </ul>

  <h3>Comparison</h3>
  <table border="1" cellpadding="5" cellspacing="0">
    <thead>
      <tr>
        <th>Feature</th>
        <th>Centralized Database</th>
        <th>Distributed Database</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>Data Location</td>
        <td>Stored in one place</td>
        <td>Spread across multiple locations</td>
      </tr>
      <tr>
        <td>Management Complexity</td>
        <td>Simple</td>
        <td>Complex</td>
      </tr>
      <tr>
        <td>Fault Tolerance</td>
        <td>Low (single point of failure)</td>
        <td>High (redundant nodes)</td>
      </tr>
      <tr>
        <td>Performance</td>
        <td>Limited by server capability</td>
        <td>Potentially higher through parallelism</td>
      </tr>
      <tr>
        <td>Cost</td>
        <td>Lower initial cost</td>
        <td>Higher infrastructure and maintenance costs</td>
      </tr>
    </tbody>
  </table>

 <div class="subhead"> <h2>Database Security</h2></div> 
  <h3>Introduction</h3>
  <p>Database security involves protecting the database against unauthorized access, misuse, or theft. It is critical because databases often store sensitive information such as personal data, financial records, and proprietary business information.</p>

  <h3>Challenges</h3>
  <ul>
    <li>Preventing unauthorized access from hackers or malicious insiders.</li>
    <li>Protecting against SQL injection and other cyber attacks.</li>
    <li>Maintaining privacy and compliance with regulations such as GDPR or HIPAA.</li>
    <li>Ensuring data availability despite threats like denial of service attacks.</li>
  </ul>

  <h3>Security Measures</h3>
  <ul>
    <li><strong>Authentication:</strong> Verifying user identities through passwords, biometrics, or tokens.</li>
    <li><strong>Authorization:</strong> Granting appropriate access rights based on user roles.</li>
    <li><strong>Encryption:</strong> Protecting data at rest and in transit using cryptographic techniques.</li>
    <li><strong>Auditing:</strong> Keeping logs of access and modifications for accountability.</li>
    <li><strong>Backup and Recovery:</strong> Regularly backing up data to recover from security breaches or data loss.</li>
  </ul>

 <div class="subhead"> <h3>Roles of DBA (Database Administrator)</h3></div>
  <p>The DBA plays a crucial role in managing database security, performance, and availability. Key responsibilities include:</p>
  <ul>
    <li>Installing and configuring the DBMS software.</li>
    <li>Defining and enforcing security policies.</li>
    <li>Performing backup and recovery operations.</li>
    <li>Monitoring system performance and tuning databases.</li>
    <li>Managing user accounts, roles, and privileges.</li>
    <li>Ensuring data integrity and compliance with regulations.</li>
  </ul>

  <div class="subhead"><h2>Practical Topics: DDL and DML Languages</h2></div>
  <p><strong>Data Definition Language (DDL)</strong> commands are used to define and modify database structures such as tables, indexes, and schemas. Common DDL commands include <code>CREATE</code>, <code>ALTER</code>, and <code>DROP</code>.</p>
  <p><strong>Data Manipulation Language (DML)</strong> commands are used to manipulate data stored within tables. These include <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>, and <code>SELECT</code>.</p>

  <div class="subhead"><h2>SQL Data Types</h2></div>
  <p>SQL supports various data types to define the nature and constraints of data stored in table fields:</p>
  <ul>
    <li><strong>CHAR(size):</strong> Fixed-length character string. Useful for storing data with a fixed size, such as country codes.</li>
    <li><strong>VARCHAR(size):</strong> Variable-length character string. Efficient for storing text with varying lengths, like names or emails.</li>
    <li><strong>BINARY(size):</strong> Fixed-length binary data, used to store raw bytes.</li>
    <li><strong>VARBINARY(size):</strong> Variable-length binary data.</li>
    <li><strong>TINYBLOB:</strong> Very small binary large object (up to 255 bytes).</li>
    <li><strong>TINYTEXT:</strong> Very small text data.</li>
    <li><strong>TEXT:</strong> Large text data (up to 65,535 characters).</li>
    <li><strong>LONGTEXT:</strong> Very large text data (up to 4GB).</li>
    <li><strong>ENUM:</strong> A string object that can have one value chosen from a list of predefined values.</li>
    <li><strong>BIT:</strong> Stores bit-field values.</li>
    <li><strong>TINYINT:</strong> Very small integer (usually 1 byte).</li>
    <li><strong>BOOLEAN:</strong> Stores true or false values (often implemented as TINYINT).</li>
    <li><strong>INTEGER:</strong> Standard integer value.</li>
    <li><strong>FLOAT:</strong> Floating-point number with single precision.</li>
    <li><strong>DOUBLE:</strong> Floating-point number with double precision.</li>
    <li><strong>DECIMAL(p,s):</strong> Fixed-point number with precision <em>p</em> and scale <em>s</em>, suitable for financial calculations.</li>
    <li><strong>DATE:</strong> Stores calendar dates (year, month, day).</li>
    <li><strong>DATETIME:</strong> Stores date and time values.</li>
  </ul>
  </div>
</div>
        </div>
      <div id="chapter4" class="border">
  <div class="text">

    
    <div class="subhead">
      <h2>C Programming</h2>
    </div>

    
    <div class="subhead">
      <h3>Functions</h3>
    </div>

    <p><strong>Introduction and Syntax:</strong>  
      A function in C is a self-contained block of code that performs a specific task. Functions help in organizing code into modular pieces, which can be reused and maintained easily. The basic syntax of a function includes:
    </p>
    <ul>
      <li><code>return_type function_name(parameter_list) { /* function body */ }</code></li>
    </ul>
    <p>Where:</p>
    <ul>
      <li><strong>return_type</strong>: The data type of the value the function returns (e.g., int, void).</li>
      <li><strong>function_name</strong>: Identifier to call the function.</li>
      <li><strong>parameter_list</strong>: Comma-separated variables passed to the function (can be empty).</li>
      <li><strong>function body</strong>: Code block enclosed in braces that performs the function's task.</li>
    </ul>

    <p><strong>Purpose and Advantages:</strong></p>
    <ul>
      <li>Breaks down complex programs into simpler sub-tasks.</li>
      <li>Enhances code reusability and readability.</li>
      <li>Makes debugging easier by isolating errors.</li>
      <li>Improves program structure and maintenance.</li>
    </ul>

    <p><strong>Components of a Function:</strong></p>
    <ul>
      <li><strong>Function Prototype:</strong> Declares the function's return type, name, and parameters before its use, helping the compiler check correctness.</li>
      <li><strong>Function Definition:</strong> Contains the actual body/code of the function.</li>
      <li><strong>Function Call:</strong> Executes the function by calling it with required arguments.</li>
      <li><strong>Return Statement:</strong> Sends a value back to the caller; if the function returns void, no value is returned.</li>
    </ul>

    <p><strong>Types of Functions:</strong></p>
    <ul>
      <li><strong>Library Functions:</strong> Predefined functions provided by the C standard library (e.g., <code>printf()</code>, <code>scanf()</code>, <code>strlen()</code>).</li>
      <li><strong>User-Defined Functions:</strong> Functions created by the programmer to perform specific tasks.</li>
    </ul>

    <p><strong>Passing Arguments to Functions:</strong></p>
    <ul>
      <li><strong>Call by Value:</strong> The function receives a copy of the variable's value. Changes inside the function do not affect the original variable.</li>
      <li><strong>Call by Reference:</strong> The function receives the address of the variable (using pointers). Changes inside the function modify the original variable.</li>
    </ul>

    <p><strong>Variable Scope:</strong></p>
    <ul>
      <li><strong>Local Variables:</strong> Declared inside functions or blocks, only accessible within that scope.</li>
      <li><strong>Global Variables:</strong> Declared outside all functions, accessible throughout the program.</li>
    </ul>

    <p><strong>Storage Classes in C:</strong> Storage classes determine the lifetime and visibility of variables.</p>
    <ul>
      <li><strong>Automatic (auto):</strong> Default for local variables; allocated when block executes and destroyed afterward.</li>
      <li><strong>External (extern):</strong> Declares a variable defined in another file or outside the current block.</li>
      <li><strong>Static:</strong> Retains the value between function calls; scope can be local or global.</li>
      <li><strong>Register:</strong> Suggests storing the variable in CPU register for faster access (may be ignored by the compiler).</li>
    </ul>

    <p><strong>Functions with Arrays:</strong></p>
    <p>Functions can accept arrays as parameters to process multiple data elements. Arrays are passed as pointers, allowing functions to access and modify the original array elements.</p>
    <pre><code>void printArray(int arr[], int size) {
  for(int i = 0; i &lt; size; i++) {
    printf("%d ", arr[i]);
  }
}
</code></pre>

    <p><strong>Recursive Functions:</strong></p>
    <p>These functions call themselves to solve problems by breaking them into smaller subproblems. They require a base case to end recursion, preventing infinite loops.</p>
    <pre><code>int factorial(int n) {
  if (n == 0) return 1; // base case
  else return n * factorial(n-1); // recursive call
}
</code></pre>

    <p><strong>Advantages and Disadvantages of Functions:</strong></p>
    <ul>
      <li><strong>Advantages:</strong> Reusability, better organization, easier maintenance, and testing.</li>
      <li><strong>Disadvantages:</strong> Overhead of function calls may reduce performance slightly; excessive recursion can cause stack overflow.</li>
    </ul>

  
    <div class="subhead">
      <h3>Structure and Union</h3>
    </div>

    <h3 class="subhead">Structure:</h3>
    <p>A structure is a user-defined data type in C that groups variables of different types under a single name, allowing representation of complex data objects.</p>
    <ul>
      <li><strong>Introduction and Syntax:</strong> Defined using the <code>struct</code> keyword.</li>
      <pre><code>struct Student {
  int id;
  char name[50];
  float marks;
};
</code></pre>
      <li><strong>Structure Size:</strong> Total size is the sum of sizes of all members plus any padding added for alignment.</li>
      <li><strong>Accessing Members:</strong> Use the dot operator (<code>.</code>) to access members of a structure variable.</li>
      <li><strong>Nested Structures:</strong> Structures can contain other structures as members to model complex data.</li>
      <li><strong>Array of Structures:</strong> You can create arrays to hold multiple structure variables, useful for handling records or lists.</li>
      <li><strong>Passing Structures to Functions:</strong> Structures can be passed by value (copy of entire structure) or by reference (using pointers) to avoid overhead.</li>
    </ul>

    <h3 class="subhead">Union:</h3>
    <p>Unions are similar to structures but share the same memory location for all members. This means only one member can hold a value at a time, making unions memory-efficient.</p>
    <ul>
      <h3 class="subhead">Introduction and Syntax:</h3></strong> Defined using the <code>union</code> keyword.</li>
      <pre><code>union Data {
  int i;
  float f;
  char str[20];
};
</code></pre>
      <h3 class="subhead">Comparison Between Structure and Union:</h3>
      <ul>
        <li>Structures allocate separate memory for each member; unions allocate shared memory equal to the largest member.</li>
        <li>Structures can store values for all members simultaneously; unions can store value for only one member at a time.</li>
        <li>Unions are used for memory optimization when only one member is used at a time (e.g., handling different data types in the same memory space).</li>
      </ul>
    </ul>

  
  <div class="subhead"><h2> Pointers in C</h2></div>

        <h3 class="subhead">Introduction and Syntax</h3>
        <p class="text">
            A pointer is a variable that stores the memory address of another variable. It is a powerful feature in C that allows direct memory access and manipulation.
            Syntax: <code>datatype *pointer_name;</code> where <code>datatype</code> is the type of variable the pointer points to.
        </p>

        <h3 class="subhead">Usage and Working</h3>
        <p class="text">
            Pointers are used to dynamically allocate memory, pass large structures or arrays efficiently to functions, and to work with complex data structures like linked lists.
            The pointer variable holds the address of another variable, and using the dereference operator <code>*</code>, you can access or modify the data stored at that address.
        </p>

        <h3 class="subhead">Concept of Value and Address</h3>
        <p class="text">
            Every variable in C has a value and a memory address. The value is the data stored, while the address is the location in memory where the value resides.
            Pointers store these addresses instead of values.
        </p>

        <h3 class="subhead">Declaration and Initialization</h3>
        <p class="text">
            Example:
            <br>
            <code>int *ptr;</code> declares a pointer to an integer.
            <br>
            <code>int x = 10;</code>
            <br>
            <code>ptr = &x;</code> initializes the pointer with the address of <code>x</code>.
        </p>

        <h3 class="subhead">Pointer and Function with code example</h3>
        <p class="text">
            Pointers can be passed to functions to modify the original variables.
        </p>
        <pre class="text">
void increment(int *p) {
    (*p)++;
}

int main() {
    int a = 5;
    increment(&a);
    // a is now 6
    return 0;
}
        </pre>

        <h3 class="subhead">Call by Reference with code example</h3>
        <p class="text">
            Using pointers, functions can change variables outside their scope by receiving addresses.
        </p>
        <pre class="text">
void swap(int *x, int *y) {
    int temp = *x;
    *x = *y;
    *y = temp;
}

int main() {
    int a = 10, b = 20;
    swap(&a, &b);
    // a is 20, b is 10
    return 0;
}
        </pre>

        <h3 class="subhead">Comparison between Call by Value and Call by Reference</h3>
        <p class="text">
            <strong>Call by Value:</strong> Passes copies of variables to functions, so changes inside function do not affect originals.
            <br>
            <strong>Call by Reference:</strong> Passes addresses via pointers, allowing functions to modify original variables.
        </p>

        <h3 class="subhead">Pointer with Arrays with code example</h3>
        <p class="text">
            Arrays and pointers are closely related; the name of the array acts as a pointer to the first element.
        </p>
        <pre class="text">
int arr[] = {1, 2, 3};
int *p = arr; // points to arr[0]
printf("%d", *(p + 1)); // prints 2
        </pre>

        <h3 class="subhead">Advantages and Disadvantages</h3>
        <p class="text">
            <strong>Advantages:</strong>
            <ul>
                <li>Efficient memory management</li>
                <li>Enable dynamic data structures</li>
                <li>Facilitate efficient array and string handling</li>
            </ul>
            <strong>Disadvantages:</strong>
            <ul>
                <li>Complexity and risk of errors (dangling pointers, memory leaks)</li>
                <li>Potential security vulnerabilities</li>
                <li>Harder to debug pointer-related bugs</li>
            </ul>
        </p>

        <div class="subhead"><h2> File Handling in C</h2></div>

        <h3 class="subhead">Concept of Data File</h3>
        <p class="text">
            A data file stores information permanently on a disk. Files can be text or binary and allow programs to save and retrieve data between runs.
        </p>

        <h3 class="subhead">Need for File Handling in C</h3>
        <p class="text">
            To process data that cannot be stored in memory during execution or to keep persistent data, C programs use file handling to read and write data to files.
        </p>

        <h3 class="subhead">Sequential and Random Files</h3>
        <p class="text">
            <strong>Sequential files:</strong> Data is accessed in order, one record after another.
            <br>
            <strong>Random files:</strong> Data can be accessed directly at any position, supporting faster retrieval.
        </p>

        <h3 class="subhead">File Handling Functions</h3>
        <p class="text">
            <strong>fopen():</strong> Opens a file. Syntax: <code>FILE *fopen(const char *filename, const char *mode);</code>
            <br>
            <strong>fclose():</strong> Closes an opened file. Syntax: <code>int fclose(FILE *stream);</code>
            <br>
            <strong>getc():</strong> Reads a character from a file. Syntax: <code>int getc(FILE *stream);</code>
            <br>
            <strong>putc():</strong> Writes a character to a file. Syntax: <code>int putc(int char, FILE *stream);</code>
            <br>
            <strong>fprintf():</strong> Writes formatted output to a file. Syntax: <code>int fprintf(FILE *stream, const char *format, ...);</code>
            <br>
            <strong>fscanf():</strong> Reads formatted input from a file. Syntax: <code>int fscanf(FILE *stream, const char *format, ...);</code>
            <br>
            <strong>getw():</strong> Reads an integer from a file. Syntax: <code>int getw(FILE *stream);</code>
            <br>
            <strong>putw():</strong> Writes an integer to a file. Syntax: <code>int putw(int w, FILE *stream);</code>
            <br>
            <strong>fgets():</strong> Reads a string from a file. Syntax: <code>char *fgets(char *str, int n, FILE *stream);</code>
            <br>
            <strong>fputs():</strong> Writes a string to a file. Syntax: <code>int fputs(const char *str, FILE *stream);</code>
            <br>
            <strong>fread():</strong> Reads data from a file. Syntax: <code>size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);</code>
            <br>
            <strong>fwrite():</strong> Writes data to a file. Syntax: <code>size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);</code>
            <br>
            <strong>remove():</strong> Deletes a file. Syntax: <code>int remove(const char *filename);</code>
            <br>
            <strong>rename():</strong> Renames a file. Syntax: <code>int rename(const char *oldname, const char *newname);</code>
        </p>

        <h3 class="subhead">Random Access Functions</h3>
        <p class="text">
            <strong>fseek():</strong> Moves the file pointer to a specified location. Syntax: <code>int fseek(FILE *stream, long offset, int whence);</code>
            <br>
            <strong>rewind():</strong> Sets the file pointer to the beginning of the file. Syntax: <code>void rewind(FILE *stream);</code>
            <br>
            <strong>ftell():</strong> Returns the current position of the file pointer. Syntax: <code>long ftell(FILE *stream);</code>
        </p>

        <h3 class="subhead">File Opening Modes</h3>
        <p class="text">
            <ul>
                <li><code>r</code>: Read mode, file must exist.</li>
                <li><code>r+</code>: Read/Write mode, file must exist.</li>
                <li><code>w</code>: Write mode, creates file if doesn't exist, truncates if exists.</li>
                <li><code>w+</code>: Read/Write mode, creates or truncates file.</li>
                <li><code>a</code>: Append mode, writes data at end, creates file if doesn't exist.</li>
                <li><code>a+</code>: Read/Append mode, creates file if doesn't exist.</li>
            </ul>
        </p>

        <h3 class="subhead">Steps to Work with File in C</h3>
        <p class="text">
            1. Define a file pointer: <code>FILE *fp;</code>
            <br>
            2. Open the file with required mode: <code>fp = fopen("file.txt", "r");</code>
            <br>
            3. Perform Read, Write or Append operations using functions.
            <br>
            4. Close the file using <code>fclose(fp);</code>
        </p>

        <h3 class="subhead">Reading Data from Files</h3>
        <p class="text">
            Functions like <code>fgetc()</code>, <code>fgets()</code>, and <code>fread()</code> can be used to read data from files.
        </p>

        <h3 class="subhead">Writing Data on Files</h3>
        <p class="text">
            Functions like <code>fputc()</code>, <code>fputs()</code>, and <code>fwrite()</code> are used to write data on files.
        </p>

        <h3 class="subhead">Appending Data Files</h3>
        <p class="text">
            Open files in append mode <code>"a"</code> or <code>"a+"</code> to add data at the end without overwriting existing content.
        </p>

        <h3 class="subhead">End of File (EOF)</h3>
        <p class="text">
            EOF indicates no more data to read from a file. It is typically checked using <code>feof()</code> function.
        </p>

        <h3 class="subhead">Typedef Keyword in C</h3>
        <p class="text">
            <code>typedef</code> allows you to create new names (aliases) for existing data types, making code more readable.
            <br>
            Example:
            <br>
            <code>typedef unsigned int uint;</code>
            <br>
            Now, <code>uint</code> can be used as a synonym for <code>unsigned int</code>.
        </p>
    </div>
</body>
